import 'dart:io';

void main() {
  print('üîß Starting code generation...');

  // Configuration
  final inputFilePath = 'lib/src/models/schema/ck_unit.dart';
  final outputFilePath = 'lib/src/models/schema/ck_unit.g.dart';

  print('üì¶ Input: $inputFilePath');

  // Read input file
  final inputFile = File(inputFilePath);
  if (!inputFile.existsSync()) {
    print('‚ùå Error: $inputFilePath not found');
    exit(1);
  }

  final content = inputFile.readAsStringSync();

  // Parse annotations
  final baseUnit = _parseBaseUnit(content);
  final unitClasses = _parseUnitClasses(content);

  if (baseUnit == null) {
    print('‚ùå Error: No @ck-base-unit annotation found');
    exit(1);
  }

  if (unitClasses.isEmpty) {
    print('‚ùå Error: No @ck-unit annotations found');
    exit(1);
  }

  print('üîç Scanning annotations...');
  print('‚úÖ Found base class: ${baseUnit.name}');
  print(
      '‚úÖ Generated ${unitClasses.length} categories classes with ${unitClasses.fold(0, (sum, c) => sum + c.units.length)} units.');
  print('‚úÖ Generated ${unitClasses.length} namespace classes');

  // Generate output
  final output = _generateOutput(baseUnit, unitClasses);

  // Write output file
  final outputFile = File(outputFilePath);
  outputFile.writeAsStringSync(output);

  print('üìù Output: $outputFilePath');
  print('üéâ Code generation completed successfully.');
}

class BaseClass {
  final String name;
  final List<Property> properties;

  BaseClass({required this.name, required this.properties});
}

class Property {
  final String name;
  final String type;
  final bool isOptional;

  Property({required this.name, required this.type, this.isOptional = false});
}

class UnitClass {
  final String name;
  final List<UnitDefinition> units;

  UnitClass({required this.name, required this.units});
}

class UnitDefinition {
  final String name;
  final String symbol;
  final num? value;

  UnitDefinition({required this.name, required this.symbol, this.value});
}

BaseClass? _parseBaseUnit(String content) {
  final baseUnitPattern = RegExp(
    r'///\s*@ck-base-unit:\s*([^\n]+)',
    multiLine: true,
  );

  final match = baseUnitPattern.firstMatch(content);
  if (match == null) return null;

  final propertiesText = match.group(1)!.trim();
  final properties = <Property>[];

  for (final prop in propertiesText.split(',')) {
    final propParts = prop.trim().split(':');
    if (propParts.length != 2) continue;

    final name = propParts[0].trim();
    final type = propParts[1].trim();
    final isOptional = type.endsWith('?');
    final cleanType = isOptional ? type.substring(0, type.length - 1) : type;

    properties.add(Property(
      name: name,
      type: cleanType,
      isOptional: isOptional,
    ));
  }

  return BaseClass(name: 'CKUnit', properties: properties);
}

List<UnitClass> _parseUnitClasses(String content) {
  final unitClassPattern = RegExp(
    r'///\s*@ck-unit:\s*([^\n]+)\s*\n\s*extension\s+(\w+)\s+on\s+(\w+)',
    multiLine: true,
  );

  final unitClasses = <UnitClass>[];

  for (final match in unitClassPattern.allMatches(content)) {
    final unitsText = match.group(1)!.trim();
    // final extensionName = match.group(2)!;
    final className = match.group(3)!;

    // Skip if it's the base class extension
    if (className == 'CKUnit') continue;

    final units = <UnitDefinition>[];
    for (final unit in unitsText.split(',')) {
      final unitParts = unit.trim().split(':');
      if (unitParts.length != 2) continue;

      final name = unitParts[0].trim();
      final symbolAndValue = unitParts[1].trim();

      final symbolAndValueParts = symbolAndValue.split('|');
      final symbol = symbolAndValueParts[0].trim();
      final value = symbolAndValueParts.length > 1
          ? num.tryParse(symbolAndValueParts[1].trim())
          : null;

      units.add(UnitDefinition(
        name: name,
        symbol: symbol,
        value: value,
      ));
    }

    unitClasses.add(UnitClass(name: className, units: units));
  }

  return unitClasses;
}

String _generateOutput(BaseClass baseClass, List<UnitClass> unitClasses) {
  final buffer = StringBuffer();

  // Header
  buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
  buffer.writeln('// Generated by tool/generate_ck_unit.dart');
  buffer.writeln('// Generated on ${DateTime.now().toIso8601String()}');
  buffer.writeln();
  buffer.writeln("part of 'ck_unit.dart';");
  buffer.writeln();

  // Base class
  buffer.writeln('/// Base unit class.');
  buffer.writeln('/// Properties are defined via @ck-base-unit annotation.');
  buffer.writeln('abstract class ${baseClass.name} {');

  // Properties - if optional, declare as nullable
  for (final prop in baseClass.properties) {
    final type = prop.isOptional ? '${prop.type}?' : prop.type;
    buffer.writeln('  final $type ${prop.name};');
  }
  buffer.writeln();

  // Constructor
  buffer.writeln('  const ${baseClass.name}(');

  // Required parameters
  for (int i = 0; i < baseClass.properties.length; i++) {
    final prop = baseClass.properties[i];
    if (!prop.isOptional) {
      buffer.write('    this.${prop.name}');
      if (i < baseClass.properties.length - 1 ||
          baseClass.properties.any((p) => p.isOptional)) {
        buffer.write(',');
      }
      buffer.writeln();
    }
  }

  // Optional parameters - group all in one set of brackets
  final optionalProperties =
      baseClass.properties.where((p) => p.isOptional).toList();
  if (optionalProperties.isNotEmpty) {
    buffer.write('    [');
    for (int i = 0; i < optionalProperties.length; i++) {
      final prop = optionalProperties[i];
      buffer.write('this.${prop.name}');
      if (i < optionalProperties.length - 1) {
        buffer.write(', ');
      }
    }
    buffer.writeln(']');
  }

  buffer.writeln('  );');
  buffer.writeln();

  // Namespace accessors
  for (final unitClass in unitClasses) {
    buffer.writeln(
        '  static const ${_deriveNamespaceName(unitClass.name)} = _${unitClass.name}Namespace();');
  }
  buffer.writeln('}');
  buffer.writeln();

  // Unit classes
  for (final unitClass in unitClasses) {
    buffer.writeln(
        '/// ${unitClass.name}-specific unit class, inherits from ${baseClass.name}.');
    buffer.writeln('class ${unitClass.name} extends ${baseClass.name} {');

    // Constructor - write everything in one line to avoid line breaks
    buffer.write('  const ${unitClass.name}(');

    // First parameter (required)
    buffer.write('super.symbol');

    // Optional parameters
    for (int i = 1; i < baseClass.properties.length; i++) {
      final prop = baseClass.properties[i];
      if (prop.isOptional) {
        buffer.write(', [super.${prop.name}]');
      }
    }

    buffer.writeln(');');
    buffer.writeln();

    // Static constants
    for (final unit in unitClass.units) {
      buffer.write(
          '  static const ${unit.name} = ${unitClass.name}(\'${unit.symbol}\'');

      // Add the value if present
      if (unit.value != null) {
        buffer.write(', ${unit.value}');
      }

      buffer.writeln(');');
    }
    buffer.writeln('}');
    buffer.writeln();
  }

  // Namespace classes
  for (final unitClass in unitClasses) {
    buffer.writeln(
        '/// Namespace class enabling ${baseClass.name}.${_deriveNamespaceName(unitClass.name)}.unitName syntax.');
    buffer.writeln('class _${unitClass.name}Namespace {');
    buffer.writeln('  const _${unitClass.name}Namespace();');
    buffer.writeln();

    // Getters
    for (final unit in unitClass.units) {
      buffer.writeln(
          '  ${unitClass.name} get ${unit.name} => ${unitClass.name}.${unit.name};');
    }
    buffer.writeln('}');
    buffer.writeln();
  }

  return buffer.toString();
}

String _deriveNamespaceName(String className) {
  // Remove "CK" prefix
  var name = className;
  if (name.startsWith('CK')) {
    name = name.substring(2);
  }
  // Remove "Unit" suffix
  if (name.endsWith('Unit')) {
    name = name.substring(0, name.length - 4);
  }
  // Convert CamelCase to lower camelCase
  if (name.isEmpty) return 'unit';
  return name[0].toLowerCase() + name.substring(1);
}

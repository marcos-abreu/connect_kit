import 'dart:io';

// ignore_for_file: avoid_print
void main() {
  print('üîç Scanning CKType definitions...');

  final inputFilePath = 'lib/src/models/schema/ck_type.dart';
  final outputFilePath = 'lib/src/models/schema/ck_type.g.dart';

  final file = File(inputFilePath);
  if (!file.existsSync()) {
    print('‚ùå Error: $inputFilePath not found');
    exit(1);
  }

  final content = file.readAsStringSync();
  final types = <String, String>{};

  // Extract simple types: static const name = CKType._('name');
  final simpleTypeRegex = RegExp(r"static const (\w+) = CKType\._\('(\w+)'\);");
  for (final match in simpleTypeRegex.allMatches(content)) {
    final name = match.group(1)!;
    final identifier = match.group(2)!;
    types[identifier] = 'CKType.$name';
  }

  // Extract composite types: static const name = _NameType._();
  final compositeTypeRegex = RegExp(r"static const (\w+) = _(\w+)Type\._\(\);");
  for (final match in compositeTypeRegex.allMatches(content)) {
    final name = match.group(1)!;
    types[name] = 'CKType.$name';
  }

  // Extract composite sub-types: CKType get subname => CKType._('parent.subname');
  final subTypeRegex =
      RegExp(r"CKType get (\w+) => (?:const )?CKType\._\('([\w.]+)'\);");
  for (final match in subTypeRegex.allMatches(content)) {
    final getterName = match.group(1)!;
    final fullPath = match.group(2)!; // e.g., "workout.distance"
    final parts = fullPath.split('.');
    if (parts.length == 2) {
      types[fullPath] = 'CKType.${parts[0]}.$getterName';
    }
  }

  if (types.isEmpty) {
    print('‚ö†Ô∏è  Warning: No types found. Check your regex patterns.');
    exit(1);
  }

  // Generate the registry code
  final output = StringBuffer();
  output.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
  output.writeln('// Generated by: dart run tool/generate_ck_type.dart');
  output.writeln('// Generated at: ${DateTime.now().toIso8601String()}');
  output.writeln();
  output.writeln("part of 'ck_type.dart';");
  output.writeln();
  output.writeln('class _\$CKTypeRegistry {');
  output.writeln('  static final Map<String, CKType> _registry = {');

  // Sort types for consistent output
  final sortedKeys = types.keys.toList()..sort();
  for (final key in sortedKeys) {
    output.writeln("    '$key': ${types[key]},");
  }

  output.writeln('  };');
  output.writeln();
  output.writeln('  static CKType fromString(String inputString) {');
  output.writeln('    if (inputString.isEmpty) {');
  output.writeln("      throw ArgumentError('Type string cannot be empty');");
  output.writeln('    }');
  output.writeln();
  output.writeln('    final type = _registry[inputString];');
  output.writeln('    if (type == null) {');
  output.writeln('      throw ArgumentError(');
  output.writeln("        'Unknown health type: \"\$inputString\". '");
  output.writeln("        'Valid types: \${_registry.keys.join(\", \")}',");
  output.writeln('      );');
  output.writeln('    }');
  output.writeln();
  output.writeln('    return type;');
  output.writeln('  }');
  output.writeln();
  output.writeln('  static CKType? fromStringOrNull(String inputString) {');
  output.writeln('    return _registry[inputString];');
  output.writeln('  }');
  output.writeln();
  output.writeln('  static bool isValid(String inputString) {');
  output.writeln('    return _registry.containsKey(inputString);');
  output.writeln('  }');
  output.writeln();
  output.writeln('  static List<CKType> get allTypes {');
  output.writeln('    return _registry.values.toList();');
  output.writeln('  }');
  output.writeln();
  output.writeln('  static List<String> get allTypeNames {');
  output.writeln('    return _registry.keys.toList();');
  output.writeln('  }');
  output.writeln('}');

  // Write the generated file
  final outputFile = File(outputFilePath);
  outputFile.writeAsStringSync(output.toString());

  print('‚úÖ Generated registry with ${types.length} types');
  print('üìù Output: ${outputFile.path}');
  print('');
  print('Types registered:');
  for (final key in sortedKeys.take(5)) {
    print('  - $key');
  }
  if (sortedKeys.length > 5) {
    print('  ... and ${sortedKeys.length - 5} more');
  }
}

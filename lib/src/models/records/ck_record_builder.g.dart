// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by tool/generate_ck_record_builder.dart
// Generated on 2025-11-20T15:55:50.798359

import 'package:connect_kit/src/models/ck_categories.dart';
import 'package:connect_kit/src/models/records/ck_data_record.dart';
import 'package:connect_kit/src/models/schema/ck_source.dart';
import 'package:connect_kit/src/models/schema/ck_type.dart';
import 'package:connect_kit/src/models/schema/ck_unit.dart';
import 'package:connect_kit/src/models/schema/ck_value.dart';

/// Factory methods for creating CKDataRecord instances
class CKRecordBuilder {
  /// Creates a activeEnergy record.
  ///
  /// [energy] The energy value.
  /// [startTime] The start time of the activeEnergy.
  /// [endTime] The end time of the activeEnergy.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the activeEnergy data.
  ///
  /// Returns a [CKDataRecord] representing the activeEnergy.
  static CKDataRecord activeEnergy({
    required num energy,
    required CKEnergyUnit energyUnit,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.activeEnergy,
      data: CKQuantityValue(energy, energyUnit),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a restingEnergy record.
  ///
  /// [energy] The energy value.
  /// [time] The time of the restingEnergy.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the restingEnergy data.
  ///
  /// Returns a [CKDataRecord] representing the restingEnergy.
  static CKDataRecord restingEnergy({
    required num energy,
    required CKEnergyUnit energyUnit,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.restingEnergy,
      data: CKQuantityValue(energy, energyUnit),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a totalEnergy record.
  ///
  /// [energy] The energy value.
  /// [startTime] The start time of the totalEnergy.
  /// [endTime] The end time of the totalEnergy.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the totalEnergy data.
  ///
  /// Returns a [CKDataRecord] representing the totalEnergy.
  static CKDataRecord totalEnergy({
    required num energy,
    required CKEnergyUnit energyUnit,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.totalEnergy,
      data: CKQuantityValue(energy, energyUnit),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a speed record.
  ///
  /// [speedSamples] The speedSamples samples.
  /// [startTime] The start time of the speed.
  /// [endTime] The end time of the speed.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the speed data.
  ///
  /// Returns a [CKDataRecord] representing the speed.
  static CKDataRecord speed({
    required List<CKSample> speedSamples,
    required CKVelocityUnit speedSamplesUnit,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.speed,
      data: CKSamplesValue(speedSamples, speedSamplesUnit),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a steps record.
  ///
  /// [count] The count value.
  /// [startTime] The start time of the steps.
  /// [endTime] The end time of the steps.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the steps data.
  ///
  /// Returns a [CKDataRecord] representing the steps.
  static CKDataRecord steps({
    required num count,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.steps,
      data: CKQuantityValue(count, CKScalarUnit.count),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a distance record.
  ///
  /// [length] The length value.
  /// [startTime] The start time of the distance.
  /// [endTime] The end time of the distance.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the distance data.
  ///
  /// Returns a [CKDataRecord] representing the distance.
  static CKDataRecord distance({
    required num length,
    required CKLengthUnit lengthUnit,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.distance,
      data: CKQuantityValue(length, lengthUnit),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a floorsClimbed record.
  ///
  /// [count] The count value.
  /// [startTime] The start time of the floorsClimbed.
  /// [endTime] The end time of the floorsClimbed.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the floorsClimbed data.
  ///
  /// Returns a [CKDataRecord] representing the floorsClimbed.
  static CKDataRecord floorsClimbed({
    required num count,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.floorsClimbed,
      data: CKQuantityValue(count, CKScalarUnit.count),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a runningPower record.
  ///
  /// [powerSamples] The powerSamples samples.
  /// [startTime] The start time of the runningPower.
  /// [endTime] The end time of the runningPower.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the runningPower data.
  ///
  /// Returns a [CKDataRecord] representing the runningPower.
  static CKDataRecord runningPower({
    required List<CKSample> powerSamples,
    required CKPowerUnit powerSamplesUnit,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.runningPower,
      data: CKSamplesValue(powerSamples, powerSamplesUnit),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a cyclingPower record.
  ///
  /// [powerSamples] The powerSamples samples.
  /// [startTime] The start time of the cyclingPower.
  /// [endTime] The end time of the cyclingPower.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the cyclingPower data.
  ///
  /// Returns a [CKDataRecord] representing the cyclingPower.
  static CKDataRecord cyclingPower({
    required List<CKSample> powerSamples,
    required CKPowerUnit powerSamplesUnit,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.cyclingPower,
      data: CKSamplesValue(powerSamples, powerSamplesUnit),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a elevation record.
  ///
  /// [length] The length value.
  /// [startTime] The start time of the elevation.
  /// [endTime] The end time of the elevation.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the elevation data.
  ///
  /// Returns a [CKDataRecord] representing the elevation.
  static CKDataRecord elevation({
    required num length,
    required CKLengthUnit lengthUnit,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.elevation,
      data: CKQuantityValue(length, lengthUnit),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a power record.
  ///
  /// [powerSamples] The powerSamples samples.
  /// [startTime] The start time of the power.
  /// [endTime] The end time of the power.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the power data.
  ///
  /// Returns a [CKDataRecord] representing the power.
  static CKDataRecord power({
    required List<CKSample> powerSamples,
    required CKPowerUnit powerSamplesUnit,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.power,
      data: CKSamplesValue(powerSamples, powerSamplesUnit),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a cyclingPedalingCadence record.
  ///
  /// [cadenceSamples] The cadenceSamples samples.
  /// [startTime] The start time of the cyclingPedalingCadence.
  /// [endTime] The end time of the cyclingPedalingCadence.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the cyclingPedalingCadence data.
  ///
  /// Returns a [CKDataRecord] representing the cyclingPedalingCadence.
  static CKDataRecord cyclingPedalingCadence({
    required List<CKSample> cadenceSamples,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.cyclingPedalingCadence,
      data: CKSamplesValue(cadenceSamples, CKScalarUnit.count),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a wheelchairPushes record.
  ///
  /// [count] The count value.
  /// [startTime] The start time of the wheelchairPushes.
  /// [endTime] The end time of the wheelchairPushes.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the wheelchairPushes data.
  ///
  /// Returns a [CKDataRecord] representing the wheelchairPushes.
  static CKDataRecord wheelchairPushes({
    required num count,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.wheelchairPushes,
      data: CKQuantityValue(count, CKScalarUnit.count),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a activityIntensity record.
  ///
  /// [intensity] The intensity category.
  /// [startTime] The start time of the activityIntensity.
  /// [endTime] The end time of the activityIntensity.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the activityIntensity data.
  ///
  /// Returns a [CKDataRecord] representing the activityIntensity.
  static CKDataRecord activityIntensity({
    required CKActivityIntensityType intensity,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.activityIntensity,
      data: CKCategoryValue(intensity),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a distanceCycling record.
  ///
  /// [length] The length value.
  /// [startTime] The start time of the distanceCycling.
  /// [endTime] The end time of the distanceCycling.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the distanceCycling data.
  ///
  /// Returns a [CKDataRecord] representing the distanceCycling.
  static CKDataRecord distanceCycling({
    required num length,
    required CKLengthUnit lengthUnit,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.distanceCycling,
      data: CKQuantityValue(length, lengthUnit),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a distanceWheelchair record.
  ///
  /// [length] The length value.
  /// [startTime] The start time of the distanceWheelchair.
  /// [endTime] The end time of the distanceWheelchair.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the distanceWheelchair data.
  ///
  /// Returns a [CKDataRecord] representing the distanceWheelchair.
  static CKDataRecord distanceWheelchair({
    required num length,
    required CKLengthUnit lengthUnit,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.distanceWheelchair,
      data: CKQuantityValue(length, lengthUnit),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a distanceSwimming record.
  ///
  /// [length] The length value.
  /// [startTime] The start time of the distanceSwimming.
  /// [endTime] The end time of the distanceSwimming.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the distanceSwimming data.
  ///
  /// Returns a [CKDataRecord] representing the distanceSwimming.
  static CKDataRecord distanceSwimming({
    required num length,
    required CKLengthUnit lengthUnit,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.distanceSwimming,
      data: CKQuantityValue(length, lengthUnit),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a distanceDownhillSnowSports record.
  ///
  /// [length] The length value.
  /// [startTime] The start time of the distanceDownhillSnowSports.
  /// [endTime] The end time of the distanceDownhillSnowSports.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the distanceDownhillSnowSports data.
  ///
  /// Returns a [CKDataRecord] representing the distanceDownhillSnowSports.
  static CKDataRecord distanceDownhillSnowSports({
    required num length,
    required CKLengthUnit lengthUnit,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.distanceDownhillSnowSports,
      data: CKQuantityValue(length, lengthUnit),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a pushCount record.
  ///
  /// [count] The count value.
  /// [startTime] The start time of the pushCount.
  /// [endTime] The end time of the pushCount.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the pushCount data.
  ///
  /// Returns a [CKDataRecord] representing the pushCount.
  static CKDataRecord pushCount({
    required num count,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.pushCount,
      data: CKQuantityValue(count, CKScalarUnit.count),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a swimmingStrokeCount record.
  ///
  /// [count] The count value.
  /// [startTime] The start time of the swimmingStrokeCount.
  /// [endTime] The end time of the swimmingStrokeCount.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the swimmingStrokeCount data.
  ///
  /// Returns a [CKDataRecord] representing the swimmingStrokeCount.
  static CKDataRecord swimmingStrokeCount({
    required num count,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.swimmingStrokeCount,
      data: CKQuantityValue(count, CKScalarUnit.count),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a walkingSpeed record.
  ///
  /// [speedSamples] The speedSamples samples.
  /// [startTime] The start time of the walkingSpeed.
  /// [endTime] The end time of the walkingSpeed.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the walkingSpeed data.
  ///
  /// Returns a [CKDataRecord] representing the walkingSpeed.
  static CKDataRecord walkingSpeed({
    required List<CKSample> speedSamples,
    required CKVelocityUnit speedSamplesUnit,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.walkingSpeed,
      data: CKSamplesValue(speedSamples, speedSamplesUnit),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a walkingStepLength record.
  ///
  /// [length] The length value.
  /// [startTime] The start time of the walkingStepLength.
  /// [endTime] The end time of the walkingStepLength.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the walkingStepLength data.
  ///
  /// Returns a [CKDataRecord] representing the walkingStepLength.
  static CKDataRecord walkingStepLength({
    required num length,
    required CKLengthUnit lengthUnit,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.walkingStepLength,
      data: CKQuantityValue(length, lengthUnit),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a walkingAsymmetry record.
  ///
  /// [percentage] The percentage value.
  /// [startTime] The start time of the walkingAsymmetry.
  /// [endTime] The end time of the walkingAsymmetry.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the walkingAsymmetry data.
  ///
  /// Returns a [CKDataRecord] representing the walkingAsymmetry.
  static CKDataRecord walkingAsymmetry({
    required num percentage,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.walkingAsymmetry,
      data: CKQuantityValue(percentage, CKScalarUnit.percent),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a walkingDoubleSupportPercentage record.
  ///
  /// [percentage] The percentage value.
  /// [time] The time of the walkingDoubleSupportPercentage.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the walkingDoubleSupportPercentage data.
  ///
  /// Returns a [CKDataRecord] representing the walkingDoubleSupportPercentage.
  static CKDataRecord walkingDoubleSupportPercentage({
    required num percentage,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.walkingDoubleSupportPercentage,
      data: CKQuantityValue(percentage, CKScalarUnit.percent),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a height record.
  ///
  /// [length] The length value.
  /// [time] The time of the height.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the height data.
  ///
  /// Returns a [CKDataRecord] representing the height.
  static CKDataRecord height({
    required num length,
    required CKLengthUnit lengthUnit,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.height,
      data: CKQuantityValue(length, lengthUnit),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a weight record.
  ///
  /// [weight] The weight value.
  /// [time] The time of the weight.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the weight data.
  ///
  /// Returns a [CKDataRecord] representing the weight.
  static CKDataRecord weight({
    required num weight,
    required CKMassUnit weightUnit,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.weight,
      data: CKQuantityValue(weight, weightUnit),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a bodyFat record.
  ///
  /// [percentage] The percentage value.
  /// [time] The time of the bodyFat.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the bodyFat data.
  ///
  /// Returns a [CKDataRecord] representing the bodyFat.
  static CKDataRecord bodyFat({
    required num percentage,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.bodyFat,
      data: CKQuantityValue(percentage, CKScalarUnit.percent),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a leanBodyMass record.
  ///
  /// [mass] The mass value.
  /// [time] The time of the leanBodyMass.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the leanBodyMass data.
  ///
  /// Returns a [CKDataRecord] representing the leanBodyMass.
  static CKDataRecord leanBodyMass({
    required num mass,
    required CKMassUnit massUnit,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.leanBodyMass,
      data: CKQuantityValue(mass, massUnit),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a bodyWaterMass record.
  ///
  /// [mass] The mass value.
  /// [time] The time of the bodyWaterMass.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the bodyWaterMass data.
  ///
  /// Returns a [CKDataRecord] representing the bodyWaterMass.
  static CKDataRecord bodyWaterMass({
    required num mass,
    required CKMassUnit massUnit,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.bodyWaterMass,
      data: CKQuantityValue(mass, massUnit),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a boneMass record.
  ///
  /// [mass] The mass value.
  /// [time] The time of the boneMass.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the boneMass data.
  ///
  /// Returns a [CKDataRecord] representing the boneMass.
  static CKDataRecord boneMass({
    required num mass,
    required CKMassUnit massUnit,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.boneMass,
      data: CKQuantityValue(mass, massUnit),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a bodyMassIndex record.
  ///
  /// [count] The count value.
  /// [time] The time of the bodyMassIndex.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the bodyMassIndex data.
  ///
  /// Returns a [CKDataRecord] representing the bodyMassIndex.
  static CKDataRecord bodyMassIndex({
    required num count,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.bodyMassIndex,
      data: CKQuantityValue(count, CKScalarUnit.count),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a biologicalSex record.
  ///
  /// [biologicalSex] The biologicalSex category.
  /// [time] The time of the biologicalSex.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the biologicalSex data.
  ///
  /// Returns a [CKDataRecord] representing the biologicalSex.
  static CKDataRecord biologicalSex({
    required CKBiologicalSexType biologicalSex,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.biologicalSex,
      data: CKCategoryValue(biologicalSex),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a bloodType record.
  ///
  /// [bloodType] The bloodType category.
  /// [time] The time of the bloodType.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the bloodType data.
  ///
  /// Returns a [CKDataRecord] representing the bloodType.
  static CKDataRecord bloodType({
    required CKBloodType bloodType,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.bloodType,
      data: CKCategoryValue(bloodType),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a dateOfBirth record.
  ///
  /// [dateOfBirth] The dateOfBirth label.
  /// [time] The time of the dateOfBirth.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the dateOfBirth data.
  ///
  /// Returns a [CKDataRecord] representing the dateOfBirth.
  static CKDataRecord dateOfBirth({
    required DateTime dateOfBirth,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.dateOfBirth,
      data: CKLabelValue(dateOfBirth.toString()),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a fitzpatrickSkinType record.
  ///
  /// [skinType] The skinType category.
  /// [time] The time of the fitzpatrickSkinType.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the fitzpatrickSkinType data.
  ///
  /// Returns a [CKDataRecord] representing the fitzpatrickSkinType.
  static CKDataRecord fitzpatrickSkinType({
    required CKFitzpatrickSkinType skinType,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.fitzpatrickSkinType,
      data: CKCategoryValue(skinType),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a menstrualFlow record.
  ///
  /// [flow] The flow category.
  /// [cycleStart] The cycleStart label.
  /// [time] The time of the menstrualFlow.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the menstrualFlow data.
  ///
  /// Returns a [CKDataRecord] representing the menstrualFlow.
  static CKDataRecord menstrualFlow({
    required CKMenstruationFlow flow,
    required bool cycleStart,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    final data = <String, CKValue>{
      'flow': CKCategoryValue(flow),
      'cycleStart': CKLabelValue(cycleStart.toString()),
    };

    final metadata = {'mainProperty': 'flow'};

    return CKDataRecord.instantaneous(
      type: CKType.menstrualFlow,
      data: CKMultipleValue(data),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
      metadata: metadata,
    );
  }


  /// Creates a cervicalMucus record.
  ///
  /// [appearance] The appearance category.
  /// [sensation] The sensation category.
  /// [time] The time of the cervicalMucus.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the cervicalMucus data.
  ///
  /// Returns a [CKDataRecord] representing the cervicalMucus.
  static CKDataRecord cervicalMucus({
    CKCervicalMucusAppearance? appearance,
    CKCervicalMucusSensation? sensation,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    final data = <String, CKValue>{
    };

    if (appearance != null) {
      data['appearance'] = CKCategoryValue(appearance!);
    }

    if (sensation != null) {
      data['sensation'] = CKCategoryValue(sensation!);
    }

    final metadata = {'mainProperty': 'appearance'};

    return CKDataRecord.instantaneous(
      type: CKType.cervicalMucus,
      data: CKMultipleValue(data),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
      metadata: metadata,
    );
  }


  /// Creates a ovulationTest record.
  ///
  /// [result] The result category.
  /// [time] The time of the ovulationTest.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the ovulationTest data.
  ///
  /// Returns a [CKDataRecord] representing the ovulationTest.
  static CKDataRecord ovulationTest({
    required CKOvulationTestResult result,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.ovulationTest,
      data: CKCategoryValue(result),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a sexualActivity record.
  ///
  /// [activity] The activity category.
  /// [time] The time of the sexualActivity.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the sexualActivity data.
  ///
  /// Returns a [CKDataRecord] representing the sexualActivity.
  static CKDataRecord sexualActivity({
    required CKSexualActivityProtection activity,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.sexualActivity,
      data: CKCategoryValue(activity),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a intermenstrualBleeding record.
  ///
  /// [time] The time of the intermenstrualBleeding.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the intermenstrualBleeding data.
  ///
  /// Returns a [CKDataRecord] representing the intermenstrualBleeding.
  /// Note: No data properties are accepted for this record type.
  static CKDataRecord intermenstrualBleeding({
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.intermenstrualBleeding,
      data: CKLabelValue('noop'), // Value will be ignored by the SDK
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a basalBodyTemperature record.
  ///
  /// [temperature] The temperature value.
  /// [measurementLocation] The measurementLocation category.
  /// [time] The time of the basalBodyTemperature.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the basalBodyTemperature data.
  ///
  /// Returns a [CKDataRecord] representing the basalBodyTemperature.
  static CKDataRecord basalBodyTemperature({
    required num temperature,
    required CKTemperatureUnit temperatureUnit,
    CKBodyTemperatureMeasurementLocation? measurementLocation,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    final data = <String, CKValue>{
      'temperature': CKQuantityValue(temperature, temperatureUnit),
    };

    if (measurementLocation != null) {
      data['measurementLocation'] = CKCategoryValue(measurementLocation!);
    }

    final metadata = {'mainProperty': 'temperature'};

    return CKDataRecord.instantaneous(
      type: CKType.basalBodyTemperature,
      data: CKMultipleValue(data),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
      metadata: metadata,
    );
  }


  /// Creates a menstruationPeriod record.
  ///
  /// [startTime] The start time of the menstruationPeriod.
  /// [endTime] The end time of the menstruationPeriod.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the menstruationPeriod data.
  ///
  /// Returns a [CKDataRecord] representing the menstruationPeriod.
  /// Note: No data properties are accepted for this record type.
  static CKDataRecord menstruationPeriod({
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.menstruationPeriod,
      data: CKLabelValue('noop'), // Value will be ignored by the SDK
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a contraceptive record.
  ///
  /// [value] The value category.
  /// [time] The time of the contraceptive.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the contraceptive data.
  ///
  /// Returns a [CKDataRecord] representing the contraceptive.
  static CKDataRecord contraceptive({
    required CKContraceptiveValue value,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.contraceptive,
      data: CKCategoryValue(value),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a progesteroneTest record.
  ///
  /// [result] The result category.
  /// [time] The time of the progesteroneTest.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the progesteroneTest data.
  ///
  /// Returns a [CKDataRecord] representing the progesteroneTest.
  static CKDataRecord progesteroneTest({
    required CKProgesteroneTestResult result,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.progesteroneTest,
      data: CKCategoryValue(result),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a heartRate record.
  ///
  /// [rateSamples] The rateSamples samples.
  /// [startTime] The start time of the heartRate.
  /// [endTime] The end time of the heartRate.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the heartRate data.
  ///
  /// Returns a [CKDataRecord] representing the heartRate.
  static CKDataRecord heartRate({
    required List<CKSample> rateSamples,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.heartRate,
      data: CKSamplesValue(rateSamples, CKScalarUnit.count),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a restingHeartRate record.
  ///
  /// [rate] The rate value.
  /// [time] The time of the restingHeartRate.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the restingHeartRate data.
  ///
  /// Returns a [CKDataRecord] representing the restingHeartRate.
  static CKDataRecord restingHeartRate({
    required num rate,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.restingHeartRate,
      data: CKQuantityValue(rate, CKScalarUnit.count),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a bloodGlucose record.
  ///
  /// [level] The level value.
  /// [specimenSource] The specimenSource category.
  /// [mealType] The mealType category.
  /// [relationToMeal] The relationToMeal category.
  /// [mealTime] The mealTime label.
  /// [time] The time of the bloodGlucose.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the bloodGlucose data.
  ///
  /// Returns a [CKDataRecord] representing the bloodGlucose.
  static CKDataRecord bloodGlucose({
    required num level,
    required CKBloodGlucoseUnit levelUnit,
    CKSpecimenSource? specimenSource,
    CKMealType? mealType,
    CKRelationToMeal? relationToMeal,
    DateTime? mealTime,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    final data = <String, CKValue>{
      'level': CKQuantityValue(level, levelUnit),
    };

    if (specimenSource != null) {
      data['specimenSource'] = CKCategoryValue(specimenSource!);
    }

    if (mealType != null) {
      data['mealType'] = CKCategoryValue(mealType!);
    }

    if (relationToMeal != null) {
      data['relationToMeal'] = CKCategoryValue(relationToMeal!);
    }

    if (mealTime != null) {
      data['mealTime'] = CKLabelValue(mealTime!.toString());
    }

    final metadata = {'mainProperty': 'level'};

    return CKDataRecord.instantaneous(
      type: CKType.bloodGlucose,
      data: CKMultipleValue(data),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
      metadata: metadata,
    );
  }


  /// Creates a bodyTemperature record.
  ///
  /// [temperature] The temperature value.
  /// [measurementLocation] The measurementLocation category.
  /// [time] The time of the bodyTemperature.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the bodyTemperature data.
  ///
  /// Returns a [CKDataRecord] representing the bodyTemperature.
  static CKDataRecord bodyTemperature({
    required num temperature,
    required CKTemperatureUnit temperatureUnit,
    CKBodyTemperatureMeasurementLocation? measurementLocation,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    final data = <String, CKValue>{
      'temperature': CKQuantityValue(temperature, temperatureUnit),
    };

    if (measurementLocation != null) {
      data['measurementLocation'] = CKCategoryValue(measurementLocation!);
    }

    final metadata = {'mainProperty': 'temperature'};

    return CKDataRecord.instantaneous(
      type: CKType.bodyTemperature,
      data: CKMultipleValue(data),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
      metadata: metadata,
    );
  }


  /// Creates a oxygenSaturation record.
  ///
  /// [percentage] The percentage value.
  /// [time] The time of the oxygenSaturation.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the oxygenSaturation data.
  ///
  /// Returns a [CKDataRecord] representing the oxygenSaturation.
  static CKDataRecord oxygenSaturation({
    required num percentage,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.oxygenSaturation,
      data: CKQuantityValue(percentage, CKScalarUnit.percent),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a respiratoryRate record.
  ///
  /// [rate] The rate value.
  /// [time] The time of the respiratoryRate.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the respiratoryRate data.
  ///
  /// Returns a [CKDataRecord] representing the respiratoryRate.
  static CKDataRecord respiratoryRate({
    required num rate,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.respiratoryRate,
      data: CKQuantityValue(rate, CKScalarUnit.count),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a vo2Max record.
  ///
  /// [vo2Max] The vo2Max value.
  /// [measurementMethod] The measurementMethod category.
  /// [time] The time of the vo2Max.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the vo2Max data.
  ///
  /// Returns a [CKDataRecord] representing the vo2Max.
  static CKDataRecord vo2Max({
    required num vo2Max,
    CKVo2MaxMeasurementMethod? measurementMethod,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    final data = <String, CKValue>{
      'vo2Max': CKQuantityValue(vo2Max, CKScalarUnit.count),
    };

    if (measurementMethod != null) {
      data['measurementMethod'] = CKCategoryValue(measurementMethod!);
    }

    final metadata = {'mainProperty': 'vo2Max'};

    return CKDataRecord.instantaneous(
      type: CKType.vo2Max,
      data: CKMultipleValue(data),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
      metadata: metadata,
    );
  }


  /// Creates a skinTemperature record.
  ///
  /// [deltaSamples] The deltaSamples samples.
  /// [baseline] The baseline value.
  /// [measurementLocation] The measurementLocation category.
  /// [startTime] The start time of the skinTemperature.
  /// [endTime] The end time of the skinTemperature.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the skinTemperature data.
  ///
  /// Returns a [CKDataRecord] representing the skinTemperature.
  static CKDataRecord skinTemperature({
    num? baseline,
    CKTemperatureUnit? baselineUnit,
    CKSkinTemperatureMeasurementLocation? measurementLocation,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    final data = <String, CKValue>{
    };

    if (baseline != null) {
      data['baseline'] = CKQuantityValue(baseline!, baselineUnit!);
    }

    if (measurementLocation != null) {
      data['measurementLocation'] = CKCategoryValue(measurementLocation!);
    }

    final metadata = {'mainProperty': 'deltaSamples'};

    return CKDataRecord(
      type: CKType.skinTemperature,
      data: CKMultipleValue(data),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
      metadata: metadata,
    );
  }


  /// Creates a heartRateVariability record.
  ///
  /// [duration] The duration value.
  /// [time] The time of the heartRateVariability.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the heartRateVariability data.
  ///
  /// Returns a [CKDataRecord] representing the heartRateVariability.
  static CKDataRecord heartRateVariability({
    required num duration,
    required CKTimeUnit durationUnit,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.heartRateVariability,
      data: CKQuantityValue(duration, durationUnit),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a peripheralPerfusionIndex record.
  ///
  /// [percentage] The percentage value.
  /// [time] The time of the peripheralPerfusionIndex.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the peripheralPerfusionIndex data.
  ///
  /// Returns a [CKDataRecord] representing the peripheralPerfusionIndex.
  static CKDataRecord peripheralPerfusionIndex({
    required num percentage,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.peripheralPerfusionIndex,
      data: CKQuantityValue(percentage, CKScalarUnit.percent),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a waterIntake record.
  ///
  /// [volume] The volume value.
  /// [startTime] The start time of the waterIntake.
  /// [endTime] The end time of the waterIntake.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the waterIntake data.
  ///
  /// Returns a [CKDataRecord] representing the waterIntake.
  static CKDataRecord waterIntake({
    required num volume,
    required CKVolumeUnit volumeUnit,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.waterIntake,
      data: CKQuantityValue(volume, volumeUnit),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a numberOfAlcoholicBeverages record.
  ///
  /// [count] The count value.
  /// [startTime] The start time of the numberOfAlcoholicBeverages.
  /// [endTime] The end time of the numberOfAlcoholicBeverages.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the numberOfAlcoholicBeverages data.
  ///
  /// Returns a [CKDataRecord] representing the numberOfAlcoholicBeverages.
  static CKDataRecord numberOfAlcoholicBeverages({
    required num count,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.numberOfAlcoholicBeverages,
      data: CKQuantityValue(count, CKScalarUnit.count),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a mindfulSession record.
  ///
  /// [sessionType] The sessionType category.
  /// [notes] The notes label.
  /// [title] The title label.
  /// [startTime] The start time of the mindfulSession.
  /// [endTime] The end time of the mindfulSession.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the mindfulSession data.
  ///
  /// Returns a [CKDataRecord] representing the mindfulSession.
  static CKDataRecord mindfulSession({
    required CKMindfulnessSessionType sessionType,
    String? notes,
    String? title,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    final data = <String, CKValue>{
      'sessionType': CKCategoryValue(sessionType),
    };

    if (notes != null) {
      data['notes'] = CKLabelValue(notes!);
    }

    if (title != null) {
      data['title'] = CKLabelValue(title!);
    }

    final metadata = {'mainProperty': 'sessionType'};

    return CKDataRecord(
      type: CKType.mindfulSession,
      data: CKMultipleValue(data),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
      metadata: metadata,
    );
  }


  /// Creates a uvExposure record.
  ///
  /// [count] The count value.
  /// [startTime] The start time of the uvExposure.
  /// [endTime] The end time of the uvExposure.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the uvExposure data.
  ///
  /// Returns a [CKDataRecord] representing the uvExposure.
  static CKDataRecord uvExposure({
    required num count,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.uvExposure,
      data: CKQuantityValue(count, CKScalarUnit.count),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a timeInDaylight record.
  ///
  /// [duration] The duration value.
  /// [startTime] The start time of the timeInDaylight.
  /// [endTime] The end time of the timeInDaylight.
  /// [startZoneOffset] Optional timezone offset at start time.
  /// [endZoneOffset] Optional timezone offset at end time.
  /// [source] The source of the timeInDaylight data.
  ///
  /// Returns a [CKDataRecord] representing the timeInDaylight.
  static CKDataRecord timeInDaylight({
    required num duration,
    required CKTimeUnit durationUnit,
    required DateTime startTime,
    required DateTime endTime,
    Duration? startZoneOffset,
    Duration? endZoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord(
      type: CKType.timeInDaylight,
      data: CKQuantityValue(duration, durationUnit),
      startTime: startTime,
      endTime: endTime,
      startZoneOffset: startZoneOffset,
      endZoneOffset: endZoneOffset,
      source: source,
    );
  }


  /// Creates a environmentalAudioExposure record.
  ///
  /// [value] The value value.
  /// [time] The time of the environmentalAudioExposure.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the environmentalAudioExposure data.
  ///
  /// Returns a [CKDataRecord] representing the environmentalAudioExposure.
  static CKDataRecord environmentalAudioExposure({
    required num value,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.environmentalAudioExposure,
      data: CKQuantityValue(value, CKPressureUnit.decibelPressure),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


  /// Creates a headphoneAudioExposure record.
  ///
  /// [value] The value value.
  /// [time] The time of the headphoneAudioExposure.
  /// [zoneOffset] Optional timezone offset at the time.
  /// [source] The source of the headphoneAudioExposure data.
  ///
  /// Returns a [CKDataRecord] representing the headphoneAudioExposure.
  static CKDataRecord headphoneAudioExposure({
    required num value,
    required DateTime time,
    Duration? zoneOffset,
    required CKSource source,
  }) {
    return CKDataRecord.instantaneous(
      type: CKType.headphoneAudioExposure,
      data: CKQuantityValue(value, CKPressureUnit.decibelPressure),
      time: time,
      zoneOffset: zoneOffset,
      source: source,
    );
  }


}
